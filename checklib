#!/usr/bin/python
# -*- coding: utf-8 -*-

import os
import re
import sys
import pisi
import magic
import types
import shutil
import tempfile
import subprocess

from optparse import OptionParser

installdb = pisi.db.installdb.InstallDB()

# Outputs the undefined symbols and unused direct dependencies of every installed package or the packages
# given through the command line.

def get_shared_objects(package='', directory=None):
    """Returns the list of shared objects in a directory or in an installed package."""
    ms = magic.open(magic.MAGIC_NONE)
    ms.load()
    shared_objects = []

    if directory:
        files = os.popen("find %s" % directory).read().strip().split("\n")
    else:
        files = set([os.path.realpath("/"+f.path) for f in installdb.get_files(package).list])

    for f in files:
        fileinfo = ms.file(f)
        if "SB shared object" in fileinfo or "SB executable" in fileinfo:
            shared_objects.append(f)

    ms.close()
    return shared_objects

def get_install_dir_for_package():
    spec = pisi.specfile.SpecFile("pspec.xml")
    return "/var/pisi/%s-%s-%s/install" % (spec.source.name, spec.history[0].version, spec.history[0].release)


def get_needed_objects(f, ldpaths="", unused=False, undefined=False):
    """Returns the NEEDED objects for f including the additional LDPATHs."""

    def parse_unused(s):
        if s:
            return [l.strip() for l in s.replace("\t", "").split("\n") if l][1:]

    def parse_undefs(s):
        if s:
            return [re.sub("^undefined symbol: (.*)\((.*)\)$", "\\1", l) \
                    for l in s.replace("\t", "").split("\n") if l.startswith("undefined symbol:")]


    objs = [l.strip().split()[1] for l in os.popen("/usr/bin/objdump -p \"%s\" | grep 'NEEDED'" % f).readlines()]

    # Get full path to the objects

    filemap = {}
    unuseds = []
    undefineds = []
    env = os.environ

    if ldpaths:
        env.update({'LD_LIBRARY_PATH': ":".join(ldpaths)})

    ldd_output = subprocess.Popen(["ldd", f], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env).communicate()[0].strip().split("\n")

    if unused or undefined:
        ldd_ur_output = subprocess.Popen(["ldd", "-u", "-r", f], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env).communicate()[0].strip()
        if unused:
            unuseds = parse_unused(ldd_ur_output)
        if undefined:
            undefineds = parse_undefs(ldd_ur_output)

    for l in [_l for _l in ldd_output if "=>" in _l]:
        # Filter these special objects
        if "linux-gate" in l or "ld-linux.so" in l:
            continue
        ls = l.split("=>")
        filemap[ls[0].strip()] = ls[1].split(" (")[0].strip()

    for i in range(len(objs)):
        if filemap.has_key(objs[i]):
            objs[i] = os.popen("readlink -f %s" % filemap[objs[i]]).read().strip()

    return (objs, unuseds, undefineds)

def get_pisi_package(f):
    """Returns the name of the PiSi package containing the file f."""
    try:
        return pisi.api.search_file(f)[0][0]
    except:
        return "Unknown"

def get_systembase_packages():
    """Returns the list of system.base packages."""
    packages = []
    cdb = pisi.db.componentdb.ComponentDB()
    for repo in pisi.db.repodb.RepoDB().list_repos():
        packages.extend(cdb.get_packages('system.base', repo))

    return packages

def check_installed_package(package, options):
    """Check for an installed package."""
    dependencies = {}
    undefineds = {}
    unuseds = {}
    objects = get_shared_objects(package=package)

    for obj in objects:
        needed_tuples = []
        objs, unused, undefined = get_needed_objects(obj, unused=options.unused, undefined=options.undefined)
        unuseds.update(dict([(obj, unused)]))
        undefineds.update(dict([(obj, undefined)]))
        for needed in objs:
            depname = get_pisi_package(needed)
            needed_tuples.append((needed, get_pisi_package(needed)))

        dependencies[obj] = needed_tuples

    return (dependencies, unuseds, undefineds)

def check_outoftree_package(options, pisi_file=None):
    """Traverses install_dir for the package to analyze dependencies."""
    if not pisi_file:
        # Checking the package in CWD
        install_dir = get_install_dir_for_package()
    else:
        # Checking a .pisi file, unpack it to somewhere
        if os.path.exists(pisi_file):
            install_dir = tempfile.mkdtemp(prefix='checklib-')
            pisi.package.Package(pisi_file).extract_install(install_dir)

    objects = get_shared_objects(directory=install_dir)
    dependencies = {}
    undefineds = {}
    unuseds = {}

    # Handle LDPATHs in /var/pisi
    ldpaths = set()
    for obj in objects:
        if obj.endswith(".so") or ".so." in obj:
            ldpaths.add(os.path.dirname(obj))

    for obj in objects:
        needed_tuples = []
        objs, unused, undefined = get_needed_objects(obj, list(ldpaths), unused=options.unused, undefined=options.undefined)
        unuseds.update(dict([(obj, unused)]))
        undefineds.update(dict([(obj, undefined)]))
        for needed in objs:
            if needed in objects:
                # object is shipped within this package
                depname = os.path.basename(os.getcwd())
            else:
                depname = get_pisi_package(needed)

            needed_tuples.append((needed, depname))

        dependencies[obj] = needed_tuples

    # Cleanup temporary directory
    if install_dir.startswith("/tmp/"):
        shutil.rmtree(install_dir)

    return (dependencies, unuseds, undefineds)

def format_output(dep_dict, colorize=True):
    """Pretty print the results in the dep_dict dictionary."""
    def _colorize(msg, color):
        colors = {'green'   : '\x1b[32;01m%s\x1b[0m',
                  'red'     : '\x1b[31;01m%s\x1b[0m',
                  'yellow'  : '\x1b[33;01m%s\x1b[0m',
                  'none'    : '\x1b[0m%s\x1b[0m',
                 }
        return colors[color if colorize else 'none'] % msg

    for f, deps in dep_dict.items():
        if deps:
            print _colorize(f, 'red')
            for dep in deps:
                if type(dep)==types.TupleType:
                    print " > %s [%s]" % (_colorize(dep[0], 'none'), _colorize(dep[1], 'yellow'))
                else:
                    print " > %s" % _colorize(dep, 'none')

            print

def print_header(msg, colorize):
    """Print the message in green color with an underline."""
    s = "%s\n%s\n" % (msg, '-'*len(msg))
    if colorize:
        print "\x1b[32;01m%s\x1b[0m" % s
    else:
        print s

def print_results(ds, options, colorize=True):
    """Print results."""
    systembase = get_systembase_packages()

    if ds[1]:
        # Dump unused analysis results
        print_header("Unused direct dependency analysis:", colorize)
        format_output(ds[1], colorize)

    if ds[2]:
        # Dump undefined symbol analysis results
        print_header("Undefined symbol analysis:", colorize)
        format_output(ds[2], colorize)

    print_header("Total direct dependencies:", colorize)

    if options.verbose:
        format_output(ds[0], colorize)
    else:
        deps = set()
        for needed in ds[0].values():
            deps = deps.union(set(filter(lambda x: (x not in systembase) or (options.systembase and x in systembase), [d[1] for d in needed])))
        if deps:
            print "\n".join(deps)


###
if __name__ == "__main__":

    # Command-line parsing
    parser = OptionParser()

    parser.add_option("-v", "--verbose",
                      action="store_true",
                      dest="verbose",
                      default=False,
                      help="Dump per-file dependency information")

    parser.add_option("-u", "--print-unused",
                      action="store_true",
                      dest="unused",
                      default=False,
                      help="Dump per-file unused direct dependencies")

    parser.add_option("-n", "--print-undefined",
                      action="store_true",
                      dest="undefined",
                      default=False,
                      help="Dump per-file undefined symbols")

    parser.add_option("-s", "--show-system-base",
                      action="store_true",
                      dest="systembase",
                      default=False,
                      help="Show system.base dependencies")

    (options, packages) = parser.parse_args()

    redirected = not sys.stdout.isatty()
    depdict = {}

    if packages:
        # An argument is passed which could be an installed package name or a *.pisi file
        if packages[0].endswith(".pisi"):
            depdict, unuseds, undefineds = check_outoftree_package(packages[0], options)
        elif packages[0] in installdb.list_installed():
            depdict, unuseds, undefineds = check_installed_package(packages[0], options)

    else:
        # else, check for the package that you've just build e.g. working directory
        depdict, unuseds, undefineds = check_outoftree_package(options)

    if not depdict:
        print "No dependency information."
        sys.exit(1)

    ds = [depdict, unuseds, undefineds]
    print_results(ds, options, colorize=not redirected)
    sys.exit(0)
